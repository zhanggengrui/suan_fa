LEETCODE 23
合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。

示例:
输入:
[
  1->4->5,
  1->3->4,
  2->6
]
输出: 1->1->2->3->4->4->5->6

解答：
方法一：分治递归
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
	def mergeKLists(self, lists: 'List[ListNode]') -> 'ListNode': 
		le = len(lists)
		if not le: return
		elif le == 1: 
			return lists[0]
		else:
			return self.merge_unit(self.mergeKLists(lists[:le // 2]),self.mergeKLists(lists[le // 2:]))	 #分治递归
            
	def merge_unit(self, head1: 'ListNode', head2: 'ListNode') -> 'ListNode':
		'''合并两个链表'''
		
		phead = ListNode(0)
		probe = phead
		while head1 and head2:
			if head1.val < head2.val:
				probe.next = head1
				head1 = head1.next
			else:
				probe.next = head2
				head2 = head2.next
			
			probe = probe.next
		probe.next = head2 if not head1 else head1
		return phead.next
解法二：暴力法
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def mergeKLists(self, lists):
        values = []
        for head in lists:
            while head!=None:
                values.append(head.val)
                head = head.next
        values.sort()
        head = ListNode(None)
        cur = head
        for val in values:
            newnode = ListNode(val)
            cur.next = newnode
            cur  = cur.next
        return head.next
==================================================================================
LEETCODE 32 
给定一个只包含 '(' 和 ')' 的字符串，找出最长的包含有效括号的子串的长度。

示例 1:
输入: "(()"
输出: 2
解释: 最长有效括号子串为 "()"

示例 2:
输入: ")()())"
输出: 4
解释: 最长有效括号子串为 "()()"

解答
class Solution(object):
    def longestValidParentheses(self, s):
        if not s or len(set(s)) == 1:
            return 0
        stack = []
        for idx in range(len(s)):
            val = s[idx]
            if stack and stack[-1][1] == '(' and val == ')':  # 有点像消消乐！！！
                stack.pop()
            else:
                stack.append((idx, val)) # 在栈里面存元组
        stack.insert(0, (-1, None))
        stack.append((len(s), None))
        res = 0
        for i in range(1, len(stack)):
            lg = stack[i][0] - stack[i-1][0] - 1
            if lg > res:
                res = lg
        return res

=====================================================================================
leetcode 56
给出一个区间的集合，请合并所有重叠的区间。

示例 1:

输入: [[1,3],[2,6],[8,10],[15,18]]
输出: [[1,6],[8,10],[15,18]]
解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
示例 2:

输入: [[1,4],[4,5]]
输出: [[1,5]]
解释: 区间 [1,4] 和 [4,5] 可被视为重叠区间。

解答：
# Definition for an interval.
# class Interval:
#     def __init__(self, s=0, e=0):
#         self.start = s
#         self.end = e
class Solution:
    def merge(self, intervals):
        """
        :type intervals: List[Interval]
        :rtype: List[Interval]
        """
        intervals.sort(key = lambda x :x.start)
        res = intervals[:1]
        for i in range(1,len(intervals)):
            if intervals[i].start<=res[-1].end:
                res[-1].end = max(res[-1].end,intervals[i].end)
            else:
                res.append(intervals[i])
        return res

===============================================================================================================================
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置，其中 k 是非负数。

示例 1:

输入: 1->2->3->4->5->NULL, k = 2
输出: 4->5->1->2->3->NULL
解释:
向右旋转 1 步: 5->1->2->3->4->NULL
向右旋转 2 步: 4->5->1->2->3->NULL
示例 2:

输入: 0->1->2->NULL, k = 4
输出: 2->0->1->NULL
解释:
向右旋转 1 步: 2->0->1->NULL
向右旋转 2 步: 1->2->0->NULL
向右旋转 3 步: 0->1->2->NULL
向右旋转 4 步: 2->0->1->NULL

解法：
class Solution:
    def rotateRight(self, head, k):

        if not head or not head.next:
            return head
        h, size = head, 1
        while h.next:
            h = h.next
            size += 1
        h.next = head   #先把原链表连成一个循环链表
        h = head
        for _ in range(size-k % size-1): #在循环链表中找断点
            h = h.next
        head = h.next
        h.next = None

        return head
========================================================================================================
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

问总共有多少条不同的路径？

例如，上图是一个7 x 3 的网格。有多少可能的路径？
说明：m 和 n 的值均不超过 100。

示例 1:
输入: m = 3, n = 2
输出: 3
解释:
从左上角开始，总共有 3 条路径可以到达右下角。
1. 向右 -> 向右 -> 向下
2. 向右 -> 向下 -> 向右
3. 向下 -> 向右 -> 向右

示例 2:
输入: m = 7, n = 3
输出: 28

解法一（回溯递归）：
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:
        if m == 0 or n == 0:
            return 0
        i = 0
        j = 0
        count = [] 
        # count = 0        如果count=0，将返回0，使用count=[]，将返回正常值
        self.dfs(m, n, i, j, count)
        return sum(count)
        # return count

    def dfs(self, m, n, i, j, count):
        if i == m - 1 and j == n - 1:
            count.append(1)
            return
        if i + 1 < m:
            self.dfs(m, n, i + 1, j, count)
        if j + 1 < n:
            self.dfs(m, n, i, j + 1, count)
  解法二：（动态规划）
  class Solution(object):
    def uniquePaths(self, m, n):
        """
        :type m: int
        :type n: int
        :rtype: int
        """
        if m == 0 or n == 0:
            return 0
        mat = [[1 for i in range(n)] for j in range(m)]
        for i in range(1,m):
            for j in range(1,n):
                mat[i][j] = mat[i-1][j]+mat[i][j-1]
        return mat[m-1][n-1]
 =============================================================================================================
 LEETCODE 64
 给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。

说明：每次只能向下或者向右移动一步。

示例:

输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小。

解答：
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        if len(grid) == 0:
            return 0       
        row = len(grid)
        col = len(grid[0])
        mat = [[0 for i in range(col)] for j in range(row)]   
        mat[0][0] = grid[0][0]
        for i in range(1,row):
            mat[i][0] = mat[i-1][0]+grid[i][0]
        for i in range(1,col):
            mat[0][i] = mat[0][i-1]+grid[0][i]
        for i in range(1,row):
            for j in range(1,col):
                mat[i][j] = grid[i][j]+min(mat[i][j-1],mat[i-1][j])
        return mat[-1][-1]
    
=================================================================================================================
LEETCODE 71
以 Unix 风格给出一个文件的绝对路径，你需要简化它。或者换句话说，将其转换为规范路径。

在 Unix 风格的文件系统中，一个点（.）表示当前目录本身；此外，两个点 （..） 表示将目录切换到上一级（指向父目录）；两者都可以是复杂相对路径的组成部分。更多信息请参阅：Linux / Unix中的绝对路径 vs 相对路径

请注意，返回的规范路径必须始终以斜杠 / 开头，并且两个目录名之间必须只有一个斜杠 /。最后一个目录名（如果存在）不能以 / 结尾。此外，规范路径必须是表示绝对路径的最短字符串。


示例 1：
输入："/home/"
输出："/home"
解释：注意，最后一个目录名后面没有斜杠。

示例 2：
输入："/../"
输出："/"
解释：从根目录向上一级是不可行的，因为根是你可以到达的最高级。

示例 3：
输入："/home//foo/"
输出："/home/foo"
解释：在规范路径中，多个连续斜杠需要用一个斜杠替换。

示例 4：
输入："/a/./b/../../c/"
输出："/c"

示例 5：
输入："/a/../../b/../c//.//"
输出："/c"

示例 6：
输入："/a//b////c/d//././/.."
输出："/a/b/c"

解答：
class Solution:
    def simplifyPath(self, path):
        res = []
        path = path.split('/')
        path = [i for i in path if i != '' and i !='.']
        for i in path:
            if i != '..':
                res.append(i)
            elif res:
                res.pop()
        return '/' + '/'.join(res)
===========================================================================================================
LEETCODE 86
给定一个链表和一个特定值 x，对链表进行分隔，使得所有小于 x 的节点都在大于或等于 x 的节点之前。
你应当保留两个分区中每个节点的初始相对位置。

示例:
输入: head = 1->4->3->2->5->2, x = 3
输出: 1->2->2->4->3->5

解答
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def partition(self, head: ListNode, x: int) -> ListNode:
        link1 = ListNode(None)
        link2 = ListNode(None)
        cur1 = link1 #存小于x的
        cur2 = link2 #存大于等于x的
        cur = head
        while cur!=None:
            if cur.val <x:
                cur1.next = cur
                cur1 = cur1.next
                cur = cur.next
            elif cur.val >= x:
                cur2.next = cur
                cur2 = cur2.next
                cur = cur.next
        cur1.next = link2.next
        cur2.next = None
        return link1.next
========================================================================================================
LEETCODE 90
给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
说明：解集不能包含重复的子集。

示例:
输入: [1,2,2]
输出:
[
  [2],
  [1],
  [1,2,2],
  [2,2],
  [1,2],
  []
]
解答：
class Solution:
    def subsetsWithDup(self, nums):
        nums.sort()
        res = []
        cur = []
        for length in range(len(nums)+1):
            self.helper(nums, res, cur, length)
        return res

    def helper(self, nums, res, cur, length):
        if len(cur) == length:
            res.append(cur[:])
            return
        for i in range(0, len(nums)):
            if i >0 and nums[i] == nums[i - 1]:
                continue
            else:
                cur.append(nums[i])
                self.helper(nums[i+1:],res,cur,length)
                cur.pop()
========================================================================================
LEETCODE 95 
给定一个整数 n，生成所有由 1 ... n 为节点所组成的二叉搜索树。

示例:
输入: 3
输出:
[
  [1,null,3,2],
  [3,2,null,1],
  [3,1,null,null,2],
  [2,1,3],
  [1,null,2,null,3]
]
解释:
以上的输出对应以下 5 种不同结构的二叉搜索树：

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

解答：
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def generateTrees(self, n):
        if n == 0:
            return []
        return self.helper(1, n)
         

    def helper(self, start, end):
        cur = []
        if start>end:
            return [None]
        for root_val in range(start, end+1):
            left_trees = self.helper(start,root_val-1)
            right_trees = self.helper(root_val+1,end)
            for left in left_trees:
                for right in right_trees:
                    root = TreeNode(root_val)
                    root.left = left
                    root.right = right
                    cur.append(root)
        return cur
       
==========================================================================================================
LEETCODE 96
给定一个整数 n，求以 1 ... n 为节点组成的二叉搜索树有多少种？

示例:
输入: 3
输出: 5
解释:
给定 n = 3, 一共有 5 种不同结构的二叉搜索树:

   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3

解答：
方法一：动态规划
class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp = [1, 1, 2]
        if n < 3: return dp[n]
        dp += [0 for i in range(n-2)]
        for i in range(3, n+1):
            for j in range(i):
                 dp[i] += dp[j]*dp[i-j-1]
        return dp[n]
        
方法二：递归
class Solution(object):
   def numTrees(self, n):
       """
       :type n: int
       :rtype: int
       """
       dp = [1, 1, 2]
       if n < 3: return dp[n]
       ans = 0 
       for i in range(n): 
           ans += self.numTrees(i)*self.numTrees(n-i-1) 
       return ans

=========================================================================================================
给定一个经过编码的字符串，返回它解码后的字符串。
编码规则为: k[encoded_string]，表示其中方括号内部的 encoded_string 正好重复 k 次。注意 k 保证为正整数。
你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。
此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 3a 或 2[4] 的输入。

示例:
s = "3[a]2[bc]", 返回 "aaabcbc".
s = "3[a2[c]]", 返回 "accaccacc".
s = "2[abc]3[cd]ef", 返回 "abcabccdcdcdef".

解答
class Solution(object):
    def decodeString(self, s_):
        times_stack = []
        chars_stack = []
        times = 0
        for s in s_:
            if s.isdigit():
                times = times*10+int(s) #数字可能不止一位
            elif s == "[":              #碰到“[”时将倍数入栈，并将倍数置为0
                times_stack.append(times)
                times = 0
                chars_stack.append(s)
            elif s.isalpha():           #碰到字母时，直接入字母栈
                chars_stack.append(s)
            elif s == "]":              #碰到“]”时，将字母栈中上一个“[”之前的字母全部弹出，并乘以倍数
                t = chars_stack.pop()
                n_chars= []
                while t!='[':
                    n_chars.append(t)
                    t = chars_stack.pop()
                times_ = times_stack.pop()
                chars_stack.append(times_*"".join(n_chars[::-1]))  # 要记得反过来，还要再放入字母栈中
        return "".join(chars_stack)
 ==============================================================================================       
