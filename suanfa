题目1 ：给定两个列表，按照两个列表对应元素的差值大小排序，输出排序结果

import collections
def paixu(a,b):
    result = []
    lens = len(a)
    dict = collections.defaultdict(list)
    for i in range(lens):
        dict[a[i]-b[i]].append([a[i],b[i]])
    list2 = sorted(dict.keys(),reverse= True)    # 对字典的键进行排序，得到字典键排序的列表
    for i in list2:
        result = result+dict[i]
    return result

if __name__ =="__main__":
    a = [10,15,23,20,6,9,7,16]
    b = [2,7,8,4,5,8,6,8]
    n_dixt = paixu(a,b)
    print(n_dixt)
    
 输出：[[20, 4], [23, 8], [10, 2], [15, 7], [16, 8], [6, 5], [9, 8], [7, 6]]

=================================================================================================================

# 哈希排序问题
#题目描述： 给定一个数组，已知数组中有大量的重复数字，对这个数组进行高效的排序
import collections
def sort(arr):
    dic = collections.defaultdict(int)
    for v in arr:
        dic[v] +=1
    _dic = sorted(dic.items(),key=lambda item:item[0])# 字典按键排序，返回一个排序的（key，value）的列表
    #_dic = sorted(dic.items(), key=lambda item: item[1])  字典按值排序，返回一个排序的（key，value）的列表
    index = 0
    for m in _dic:
        count = m[1]
        while count>0:
            arr[index] = m[0]
            index +=1
            count -=1
    return arr

if __name__ =="__main__":
    arr = [15,12,15,2,2,12,2,3,12,100,2,2]
    arr_ = arr[:]
    print(sorted(arr_))
    print(arr)
    print(sort(arr))

==================================================================================================================

题目描述：求一个数组的连续字列表的最大和
方法一：
# 分治思想解决连续字列表的最大和问题
def Mid_max(array):
    mid = len(array)//2
    left_sum = 0
    right_sum = 0
    left_max = 0
    right_max = 0
    for i in range(mid,-1,-1):
        left_sum += array[i]
        left_max = max(left_max,left_sum)
    for j in range(mid+1,len(array),1):
        right_sum += array[j]
        right_max = max(right_max,right_sum)
    return left_max+right_max

def max_sub_array(array):
    if len(array) < 2:
        return array[0]
    mid = len(array)//2
    left_array = array[:mid]
    right_array = array[mid:]
    left_max = max_sub_array(left_array)
    right_max = max_sub_array(right_array)
    mid_max = Mid_max(array)
    return max(left_max,right_max,mid_max)

方法二：动态规划解决
# 动态规划解决
def max_sub_array2(arr):
    maxsum = 0
    maxtmp = 0
    for i in range(len(arr)):
        if maxtmp <= 0:
            maxtmp = arr[i]
        else:
            maxtmp = maxtmp+arr[i]
        if maxtmp > maxsum:
            maxsum = maxtmp
    return maxsum

if __name__ =="__main__":
    array = [-2,1,-3,4,-1,2,1,-5,4]
    print(max_sub_array(array))
    print(max_sub_array2(array))
    
=======================================================================================================
题目描述：
给一个字符串数组，找出其中最长的字符串，并且它可以有数组中的其他数组组合而成（p212）
class Longestword():
    def getlongeststr(self,strarray):
        strarray = sorted(strarray,key=len,reverse=True)
        for i in range(len(strarray)):
            if self.iscontain(strarray,strarray[i],len(strarray[i])):
                return strarray[i]
        return False

    def iscontain(self,strarray,word,length):
        lens = len(word)
        if len(word) == 0:
            return True
        for i in range(1,lens+1):
            if i == length:                                    # 只在第一层递归的时候起作用，因为后面的递归的i不可能再等于lenth
                return False
            str = word[:i]
            if self.find(strarray,str):
                if self.iscontain(strarray,word[i:],length):   # 只寻找一种情况即可
                    return True
        return False

    def find(self,strarray,str):
        lens = len(strarray)
        for i in range(lens):
            if strarray[i] == str:
                return True
        return False


if __name__ =="__main__":
     strarray = ["test","tester","testertest",'testing',"apple",'seattle',"banana","ngcat",'batti',"testingtester","testbattingcat"]
     lw = Longestword()
     longestword = lw.getlongeststr(strarray)
     if longestword != False:
        print(longestword)
