#非递归
def b_search(arr,target): 
    l = 0
    r = len(arr)-1
    mid = -1
    while l<=r:
        mid = l + (r-l)//2
        if arr[mid] == target:
            return mid
        if arr[mid] < target:
            l = mid + 1
        else:
            r = mid -1
    return -1    # 没找到该数
    return left  # 返回大于target的所有数中，最小的
    return right # 返回小于target的所有数中最大的

#递归
def b_search(arr,target,l,r):
    if l > r:
        return -1
    mid = l + (r - l) // 2
    if arr[mid] == target:
        return mid
    if arr[mid] < target:
        return b_search(arr,target,mid+1,r)
    else:
        return b_search(arr,target,l,mid-1)
        
===============================================================================================================
LEETCODE 33
假设按照升序排序的数组在预先未知的某个点上进行了旋转。
( 例如，数组 [0,1,2,4,5,6,7] 可能变为 [4,5,6,7,0,1,2] )。
搜索一个给定的目标值，如果数组中存在这个目标值，则返回它的索引，否则返回 -1 。
你可以假设数组中不存在重复的元素。
你的算法时间复杂度必须是 O(log n) 级别。

示例 1:
输入: nums = [4,5,6,7,0,1,2], target = 0
输出: 4

示例 2:
输入: nums = [4,5,6,7,0,1,2], target = 3
输出: -1

解答：
class Solution:
    def search(self, nums: List[int], target: int) -> int:
        return self.b_search(nums,target)
        
    def b_search(self,nums,target):
        l = 0 
        r = len(nums)-1
        while l <= r:
            mid = l + (r-l)//2
            if nums[mid] == target:
                return mid
            if nums[l] <= nums[mid]: # 左面排好序
                if target >= nums[l] and target <= nums[mid]:  # target 在左面的区间中
                    r = mid-1
                else:
                    l = mid +1
            
            else:                    # 右面排好序
                if target >= nums[mid] and target <= nums[r]:  # target 在右面的区间中
                    l = mid + 1
                else:
                    r = mid - 1
        return -1

===============================================================================================================
LEETCODE 34 
给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。
你的算法时间复杂度必须是 O(log n) 级别。
如果数组中不存在目标值，返回 [-1, -1]。

示例 1:
输入: nums = [5,7,7,8,8,10], target = 8
输出: [3,4]

示例 2:
输入: nums = [5,7,7,8,8,10], target = 6
输出: [-1,-1]

class Solution:
    def searchRange(self, nums,target):
        low = self.low_search(nums,target)
        up = self.up_search(nums,target)
        return [low,up]
    
    def low_search(self,nums,target):
        l = 0 
        r = len(nums) - 1
        while l <= r:
            mid = l+(r-l)//2
            if nums[mid] == target and(mid == 0 or nums[mid-1] <target):
                return mid
            if nums[mid] >= target:
                r = mid - 1
            else:
                l = mid + 1
        return -1
    
    def up_search(self,nums,target):
        l = 0
        r = len(nums) - 1
        while l <= r:
            mid = l + (r-l)//2
            if nums[mid] == target and(mid == len(nums)-1 or nums[mid+1]>target):
                return mid
            if nums[mid] <= target:
                l = mid + 1
            else:
                r = mid - 1
        return -1

===============================================================================================================
LEETCODE 35 
给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。

示例 1:
输入: [1,3,5,6], 5
输出: 2

示例 2:
输入: [1,3,5,6], 2
输出: 1

示例 3:
输入: [1,3,5,6], 7
输出: 4

示例 4:
输入: [1,3,5,6], 0
输出: 0

解答：
class Solution:
    def searchInsert(self, nums: List[int], target: int) -> int:
        res = self.b_search(nums,target)
        if res == -1:
            return len(nums)
        else:
            return res
    
    def b_search(self,nums,target):
        l = 0
        r = len(nums)-1
        mid = 0
        while l<=r:
            mid = l+(r-l)//2
            if nums[mid] >= target and(mid == 0 or target > nums[mid-1]):
                return mid
            if nums[mid] >= target:
                r = mid - 1
            else:
                l = mid + 1
        return -1


