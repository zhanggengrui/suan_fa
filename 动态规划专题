#题目一：求两个字符串的最长公共子串
def get_max_sub_str(arr1,arr2):
    res = ''
    len1 = len(arr1)
    len2 = len(arr2)
    mat = [[None for i in range(len1+1)]for j in range(len2+1)]
    for i in range(len1+1):
        mat[0][i] = 0
    for j in range(len2+1):
        mat[j][0] = 0
    maxs = 0
    maxindex = 0
    for i in range(0,len1+1):
        for j in range(0,len2+1):
            if arr1[i-1] == arr2[j-1]:
                mat[i][j] = mat[i-1][j-1]+1
                if mat[i][j] > maxs:
                    maxs = mat[i][j]
                    maxindex = i
            else:
                mat[i][j] = 0
    i = maxindex - maxs
    while i <maxindex:
        res = res+arr1[i]
        i +=1

    return res


if __name__ =="__main__":
    arr1 = 'abccade'
    arr2 = 'dgcadde'
    print(get_max_sub_str(arr1,arr2))
    
======================================================================================

题目 ：求字符串里的最长回文子串
class Solution2(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return None
        lens=len(s)
        if lens<2:
            return s
        maxlen=0
        start=0
        dp=[[0]*lens]*lens
 
        #step 1
        for i in range(lens):
            dp[i][i]=True                 #长度为1的
            if i<lens-1 and s[i]==s[i+1]: #长度为2的
                dp[i][i+1]=1
                start=i
                maxlen=2
 
        #step 2 
        for i in range(3,lens+1):         # 长度大于等于3的
            for j in range(0,lens-i+1):   
                r=j+i-1
                if dp[j+1][r-1] and s[j]==s[r]:
                    dp[j][r]=1
                    maxlen=i
                    start=j
        #step 3
        if maxlen>=2:
            return s[start:start+maxlen]
        return None
        
===============================================================================
题目：最长递增子序列
def getmaxAscendinglen(arr):
    lens = len(arr)
    mat = [ 1 for i in range(lens)]
    maxlen = 1
    for i in range(lens):
        for j in range(i):
            if arr[i] > arr[j] :
                mat[i] = max(mat[j]+1,mat[i])
                if mat[i] > maxlen:
                    maxlen = mat[i]
    return maxlen


if __name__ =="__main__":
    s = "xbcdza"
    print(getmaxAscendinglen(s))
=====================================================================================
题目：最大连续子序列和（leetcode 53）
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6

解答：
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        '''if len(nums) == 0:
            return None'''
        lens = len(nums)
        dp = [None for i in range(lens)] 
        dp[0] = nums[0]
        for j in range(1,lens):
            dp[j] = max(dp[j-1]+nums[j],nums[j])
        maxs = max(dp)
        return maxs

======================================================================================
# 题目二：挖矿问题
def max_gold(arr1,arr2):
    arr1.insert(0,0) # gold
    arr2.insert(0,0) # man
    len1 = len(arr1)
    mat = [[0 for i in range(11)]for j in range(len1)]
    for i in range(1,len1):
        for j in range(1,11):
            if arr2[i] > j:
                mat[i][j] = mat[i-1][j]
            else:
                mat[i][j] = max(arr1[i]+mat[i-1][j-arr2[i]],mat[i-1][j])
    return mat


if __name__ =="__main__":
    arr1 = [400,500,200,300,350]
    arr2 = [5,5,3,4,3]
    mat = max_gold(arr1,arr2)
    for i in mat:
        print(i)
        

=====================================================================================
题目三：背包问题
# 题目描述，有一个容量为8的背包，要装下4个物品，物品的重量和价值如下，求这个包能装的最大的价值
# w = [2,3,4,5]
# v = [3,4,5,6]

#求解能装下的价值最高的
def bag(w,v,n):
    w.insert(0,0)
    v.insert(0,0)
    lens = len(w)
    mat = [[0 for i in range(n+1)]for j in range(lens)]
    for i in range(1,lens):
        for j in range(1,n+1):
            if w[i]>j:
                mat[i][j] = mat[i-1][j]
            else:
                mat[i][j] = max(v[i]+mat[i-1][j-w[i]],mat[i-1][j])
    w.pop(0)
    v.pop(0)
    return mat

#找出到底装了哪些物品
def find_witch(mat,w):
    w.insert(0,0)
    result =[]
    m = len(mat)
    n= len(mat[0])-1
    for i in range(m-1,0,-1):
        if mat[i][n] > mat[i-1][n]: #如果大于，说明这个东西被选中了，调到mat[i-1][n-w[i]]
            result.append(i)
            n = n - w[i]
    return result

if __name__ =="__main__" :
    w = [2,3,4,5]
    v = [3,4,5,6]
    mat = bag(w,v,8)
    for i in mat:
        print(i)
    print(find_witch(mat,w))

=======================================================================================================
# 题目：求两个字符串的相对编辑距离 （书P222）
def edit_distance(s1,s2):
    if s1 == None and s2 == None:
        return 0
    if s1 == None:
        return len(s2)
    if s2 == None:
        return len(s1)
    s1 = '0' + s1
    s2 = '0' + s2
    mat = [[0 for i in range(len(s2))]for j in range(len(s1))]
    for i in range(len(s2)):
        mat[0][i] = i
    for j in range(len(s1)):
        mat[j][0] = j
    for i in range(1,len(s1)):
        for j in range(1,len(s2)):
            if s1[i] == s2[j]:
                mat[i][j] = min(mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1])
            else:
                mat[i][j] = min(mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1]+1)
    s1 = s1[1:]
    for i in mat:
        print(i)
    return mat[-1][-1]

if __name__ =="__main__":
    s1 = 'bciln'
    s2 = 'fciling'
    print(edit_distance(s1,s2))


=========================================================================================
题目寻找最短路径（书P224）
def get_min_path(arr):
    if arr == None:
        return None
    row = len(arr)
    col = len(arr[0])
    mat = [[0 for i in range(col)] for j in range(row)]
    mat[0][0] = arr[0][0]
    for i in range(1,col):
        mat[0][i] = mat[0][i-1]+arr[0][i]
    for j in range(row):
        mat[j][0] = mat[j-1][0] + arr[j][0]
    for i in range(1,row):
        for j in range(1,col):
            mat[i][j] = min (mat[i-1][j],mat[i][j-1])+arr[i][j]
    for i in mat:
        print(i)
    return mat[-1][-1]


if __name__ =="__main__":
    arr=[[1,4,3],[8,7,5],[2,1,5]]
    print(get_min_path(arr))
============================================================================
LEETCODE 64
给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

示例:
输入:
[
  [1,3,1],
  [1,5,1],
  [4,2,1]
]
输出: 7
解释: 因为路径 1→3→1→1→1 的总和最小

解法一：递归尝试：
class Solution(object):
    def minPathSum(self, grid):
        return self.walk(grid,0,0)
    
    def walk(self,grid,i, j):
        if i == len(grid)-1 and j == len(grid[0])-1:
            return grid[i][j]
        if i == len(grid)-1:
            return grid[i][j] + self.walk(grid,i,j+1)
        if j == len(grid[0])-1:
            return grid[i][j] + self.walk(grid,i+1,j)
        right = self.walk(grid,i,j+1)
        down = self.walk(grid,i+1,j)
        return grid[i][j] + min(right,down)
解法二：动态规划
class Solution(object):
    def minPathSum(self, grid):
        row = len(grid)
        col = len(grid[0])
        dp = [[None for i in range(col)] for j in range(row)]
        dp[-1][-1] = grid[-1][-1]
        for i in range(col-2,-1,-1):
            dp[row-1][i] = dp[row-1][i+1] + grid[row-1][i]
        for j in range(row-2,-1,-1):
            dp[j][col-1] = dp[j+1][col-1] + grid[j][col-1]
        for i in range(row-2,-1,-1):
            for j in range(col-2,-1,-1):
                dp[i][j] = grid[i][j] + min(dp[i][j+1],dp[i+1][j])
        return dp[0][0]
解法三：动态规划
class Solution:
    def minPathSum(self, grid: List[List[int]]) -> int:
        if len(grid) == 0:
            return 0
        
        row = len(grid)
        col = len(grid[0])
        mat = [[0 for i in range(col)] for j in range(row)]   
        mat[0][0] = grid[0][0]
        for i in range(1,row):
            mat[i][0] = mat[i-1][0]+grid[i][0]
        for i in range(1,col):
            mat[0][i] = mat[0][i-1]+grid[0][i]
        for i in range(1,row):
            for j in range(1,col):
                mat[i][j] = grid[i][j]+min(mat[i][j-1],mat[i-1][j])
        return mat[-1][-1]
    
==================================================================================================
LEETCODE 139
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，判定 s 是否可以被空格拆分为一个或多个在字典中出现的单词。

拆分时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：
输入: s = "leetcode", wordDict = ["leet", "code"]
输出: true
解释: 返回 true 因为 "leetcode" 可以被拆分成 "leet code"。
示例 2：
输入: s = "applepenapple", wordDict = ["apple", "pen"]
输出: true
解释: 返回 true 因为 "applepenapple" 可以被拆分成 "apple pen apple"。
     注意你可以重复使用字典中的单词。
示例 3：
输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
输出: false

解答：
class Solution(object):
    def wordBreak(self, s, wordDict):
        # 求字典中最长字符串
        maxlen=0
        for word in wordDict:
            if len(word)>maxlen:
                maxlen=len(word)
 
        res=[0]*len(s)
        for i in range(len(s)):
            p=i
            while(p>=0 and i-p<=maxlen):
                # 两个条件
                if (res[p]==1 and s[p+1:i+1] in wordDict) or (p==0 and s[p:i+1] in wordDict):
                    res[i]=1
                    break
                p-=1
                
        return res[-1]
============================================================================================
LEETCODE 140
给定一个非空字符串 s 和一个包含非空单词列表的字典 wordDict，在字符串中增加空格来构建一个句子，使得句子中所有的单词都在词典中。返回所有这些可能的句子。
说明：
分隔时可以重复使用字典中的单词。
你可以假设字典中没有重复的单词。
示例 1：
输入:
s = "catsanddog"
wordDict = ["cat", "cats", "and", "sand", "dog"]
输出:
[
  "cats and dog",
  "cat sand dog"
]
示例 2：
输入:
s = "pineapplepenapple"
wordDict = ["apple", "pen", "applepen", "pine", "pineapple"]
输出:
[
  "pine apple pen apple",
  "pineapple pen apple",
  "pine applepen apple"
]
解释: 注意你可以重复使用字典中的单词。
示例 3：
输入:
s = "catsandog"
wordDict = ["cats", "dog", "sand", "and", "cat"]
输出:
[]

解答：
class Solution(object):
    def wordBreak(self, s, wordDict):
        if self.helper1(s,wordDict):
            self.res = []
            self.tmp = []
            self.helper(s, wordDict)
            return self.res
        else:
            return []
    
    def helper1(self,s,wordDict):
        # 求字典中最长字符串
        maxlen=0
        for word in wordDict:
            if len(word)>maxlen:
                maxlen=len(word)
        res=[0]*len(s)
        for i in range(len(s)):
            p=i
            while(p>=0 and i-p<=maxlen):
                # 两个条件
                if (res[p]==1 and s[p+1:i+1] in wordDict) or (p==0 and s[p:i+1] in wordDict):
                    res[i]=1
                    break
                p-=1
        return res[-1]

    def helper(self, s, wordDict):
        if len(s) == 0:
            self.res.append(" ".join(self.tmp))
            return
        for i in range(1, len(s)+1):
            if s[:i] in wordDict:
                self.tmp.append(s[:i])
                self.helper(s[i:], wordDict)
                self.tmp.pop()
================================================================================================
LEETCODE 560
给定一个整数数组和一个整数 k，你需要找到该数组中和为 k 的连续的子数组的个数。

示例 1 :
输入:nums = [1,1,1], k = 2
输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。

解法：
遍历数组每一个位置，对每一个未知计算从0位置到该位置的累加和；
假如到了位置i，累加和是sums，此时在之前的数组里面找，是否存在一个位置：从0位置到该位置的累加和等于（k-sums）
如果存在位置x，则从x+1到位置i的子数组和为k。

class Solution:
    def subarraySum(self, nums, k ) :
        d = dict()
        d[0] = [-1]
        sums = 0
        res = 0
        for i in range(len(nums)):
            sums += nums[i]
            if (sums - k) in d:
                res += len(d[sums - k])
            d[sums] = d.get(sums,[])
            d[sums].append(i)
        return res

===============================================================================================
LEETCODE 518 
给定不同面额的硬币和一个总金额。写出函数来计算可以凑成总金额的硬币组合数。假设每一种面额的硬币有无限个。 

示例 1:
输入: amount = 5, coins = [1, 2, 5]
输出: 4
解释: 有四种方式可以凑成总金额:
5=5
5=2+2+1
5=2+1+1+1
5=1+1+1+1+1

示例 2:
输入: amount = 3, coins = [2]
输出: 0
解释: 只用面额2的硬币不能凑成总金额3。

示例 3:
输入: amount = 10, coins = [10] 
输出: 1

解法一：暴力尝试
class Solution:
    def change(self, amount, coins):
        return self.helper(coins,0,amount)

    #arr： 数组（不变）
    #i：   从第i个位置开始
    #num： 还剩下需要凑的钱
    def helper1(self,arr,i,num):
        if i == len(arr):
            if num ==0:
                return 1
            else:
                return 0
        count = 0
        res = 0
        while num - arr[i]*count >= 0:
            res = res + self.helper(arr,i+1,num-arr[i]*count)
            count += 1
        return res
        
解法二：动态规划
def helper2(self, arr, amount, i, num):
        dp = [[0 for i in range(amount + 1)] for j in range(len(arr)+1)]
        for j in range(amount + 1):
            if j == 0:
                dp[len(arr)][j] = 1
            else:
                dp[len(arr)][j] = 0
        for i in range(len(arr)-1, -1,-1):
            for j in range(0, amount + 1):
                dp[i][j] = 0
                count = 0
                while j - arr[i] * count >= 0:
                    dp[i][j] += dp[i+1][j - arr[i] * count]
                    count += 1
        return dp[0][-1]
        
 解法三：动态规划（优化）
 def helper3(self, arr, amount, i, num):
        dp = [[0 for i in range(amount + 1)] for j in range(len(arr)+1)]
        for j in range(amount + 1):
            if j == 0:
                dp[len(arr)][j] = 1
            else:
                dp[len(arr)][j] = 0
        for i in range(len(arr)-1, -1,-1):
            for j in range(0, amount + 1):
                if j -arr[i] >= 0:
                    dp[i][j] = dp[i+1][j] + dp[i][j-arr[i]]
                else:
                    dp[i][j] = dp[i+1][j]
        return dp[0][-1]
        
 解法四：动态规划（空间优化）
 def helper4(self,arr,amount,i,num):
        dp = [0 for i in range(amount+1)]
        dp[0] = 1
        for a in arr:
            for j in range(a,amount+1):
                dp[j] = dp[j]+dp[j-a]
        return dp[-1]

