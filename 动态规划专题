#题目一：求两个字符串的最长公共子串
def get_max_sub_str(arr1,arr2):
    res = ''
    len1 = len(arr1)
    len2 = len(arr2)
    mat = [[None for i in range(len1+1)]for j in range(len2+1)]
    for i in range(len1+1):
        mat[0][i] = 0
    for j in range(len2+1):
        mat[j][0] = 0
    maxs = 0
    maxindex = 0
    for i in range(0,len1+1):
        for j in range(0,len2+1):
            if arr1[i-1] == arr2[j-1]:
                mat[i][j] = mat[i-1][j-1]+1
                if mat[i][j] > maxs:
                    maxs = mat[i][j]
                    maxindex = i
            else:
                mat[i][j] = 0
    i = maxindex - maxs
    while i <maxindex:
        res = res+arr1[i]
        i +=1

    return res


if __name__ =="__main__":
    arr1 = 'abccade'
    arr2 = 'dgcadde'
    print(get_max_sub_str(arr1,arr2))
    
======================================================================================

题目 ：求字符串里的最长回文子串
class Solution2(object):
    def longestPalindrome(self, s):
        """
        :type s: str
        :rtype: str
        """
        if not s:
            return None
        lens=len(s)
        if lens<2:
            return s
        maxlen=0
        start=0
        dp=[[0]*lens]*lens
 
        #step 1
        for i in range(lens):
            dp[i][i]=True                 #长度为1的
            if i<lens-1 and s[i]==s[i+1]: #长度为2的
                dp[i][i+1]=1
                start=i
                maxlen=2
 
        #step 2 
        for i in range(3,lens+1):         # 长度大于等于3的
            for j in range(0,lens-i+1):   
                r=j+i-1
                if dp[j+1][r-1] and s[j]==s[r]:
                    dp[j][r]=1
                    maxlen=i
                    start=j
        #step 3
        if maxlen>=2:
            return s[start:start+maxlen]
        return None
        
===============================================================================
题目：最长递增子序列
def getmaxAscendinglen(arr):
    lens = len(arr)
    mat = [ 1 for i in range(lens)]
    maxlen = 1
    for i in range(lens):
        for j in range(i):
            if arr[i] > arr[j] :
                mat[i] = max(mat[j]+1,mat[i])
                if mat[i] > maxlen:
                    maxlen = mat[i]
    return maxlen


if __name__ =="__main__":
    s = "xbcdza"
    print(getmaxAscendinglen(s))
=====================================================================================
题目：最大连续子序列和（leetcode 53）
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

示例:

输入: [-2,1,-3,4,-1,2,1,-5,4],
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6

解答：
class Solution:
    def maxSubArray(self, nums):
        """
        :type nums: List[int]
        :rtype: int
        """
        '''if len(nums) == 0:
            return None'''
        lens = len(nums)
        dp = [None for i in range(lens)] 
        dp[0] = nums[0]
        for j in range(1,lens):
            dp[j] = max(dp[j-1]+nums[j],nums[j])
        maxs = max(dp)
        return maxs

======================================================================================
# 题目二：挖矿问题
def max_gold(arr1,arr2):
    arr1.insert(0,0) # gold
    arr2.insert(0,0) # man
    len1 = len(arr1)
    mat = [[0 for i in range(11)]for j in range(len1)]
    for i in range(1,len1):
        for j in range(1,11):
            if arr2[i] > j:
                mat[i][j] = mat[i-1][j]
            else:
                mat[i][j] = max(arr1[i]+mat[i-1][j-arr2[i]],mat[i-1][j])
    return mat


if __name__ =="__main__":
    arr1 = [400,500,200,300,350]
    arr2 = [5,5,3,4,3]
    mat = max_gold(arr1,arr2)
    for i in mat:
        print(i)
        

=====================================================================================
题目三：背包问题
# 题目描述，有一个容量为8的背包，要装下4个物品，物品的重量和价值如下，求这个包能装的最大的价值
# w = [2,3,4,5]
# v = [3,4,5,6]

#求解能装下的价值最高的
def bag(w,v,n):
    w.insert(0,0)
    v.insert(0,0)
    lens = len(w)
    mat = [[0 for i in range(n+1)]for j in range(lens)]
    for i in range(1,lens):
        for j in range(1,n+1):
            if w[i]>j:
                mat[i][j] = mat[i-1][j]
            else:
                mat[i][j] = max(v[i]+mat[i-1][j-w[i]],mat[i-1][j])
    w.pop(0)
    v.pop(0)
    return mat

#找出到底装了哪些物品
def find_witch(mat,w):
    w.insert(0,0)
    result =[]
    m = len(mat)
    n= len(mat[0])-1
    for i in range(m-1,0,-1):
        if mat[i][n] > mat[i-1][n]: #如果大于，说明这个东西被选中了，调到mat[i-1][n-w[i]]
            result.append(i)
            n = n - w[i]
    return result

if __name__ =="__main__" :
    w = [2,3,4,5]
    v = [3,4,5,6]
    mat = bag(w,v,8)
    for i in mat:
        print(i)
    print(find_witch(mat,w))

=======================================================================================================
# 题目：求两个字符串的相对编辑距离 （书P222）
def edit_distance(s1,s2):
    if s1 == None and s2 == None:
        return 0
    if s1 == None:
        return len(s2)
    if s2 == None:
        return len(s1)
    s1 = '0' + s1
    s2 = '0' + s2
    mat = [[0 for i in range(len(s2))]for j in range(len(s1))]
    for i in range(len(s2)):
        mat[0][i] = i
    for j in range(len(s1)):
        mat[j][0] = j
    for i in range(1,len(s1)):
        for j in range(1,len(s2)):
            if s1[i] == s2[j]:
                mat[i][j] = min(mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1])
            else:
                mat[i][j] = min(mat[i-1][j]+1,mat[i][j-1]+1,mat[i-1][j-1]+1)
    s1 = s1[1:]
    for i in mat:
        print(i)
    return mat[-1][-1]

if __name__ =="__main__":
    s1 = 'bciln'
    s2 = 'fciling'
    print(edit_distance(s1,s2))


=========================================================================================
题目寻找最短路径（书P224）
def get_min_path(arr):
    if arr == None:
        return None
    row = len(arr)
    col = len(arr[0])
    mat = [[0 for i in range(col)] for j in range(row)]
    mat[0][0] = arr[0][0]
    for i in range(1,col):
        mat[0][i] = mat[0][i-1]+arr[0][i]
    for j in range(row):
        mat[j][0] = mat[j-1][0] + arr[j][0]
    for i in range(1,row):
        for j in range(1,col):
            mat[i][j] = min (mat[i-1][j],mat[i][j-1])+arr[i][j]
    for i in mat:
        print(i)
    return mat[-1][-1]


if __name__ =="__main__":
    arr=[[1,4,3],[8,7,5],[2,1,5]]
    print(get_min_path(arr))
