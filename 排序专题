题目：给定一个数组arr和数num，将arr中小于num的数放在数组的左边，等于num的数放在中间，大于num的数放在右边：
def partition1(arr,num,l,r):
    less = l - 1
    more = r + 1
    cur = l
    while cur < more:
        if arr[cur] == num:
            cur += 1
        elif arr[cur] < num:
            arr[cur] , arr[less+1] = arr[less+1], arr[cur]
            cur += 1
            less +=1
        elif arr[cur] > num:
            arr[cur] , arr[more-1] = arr[more-1] , arr[cur]
            more -= 1
    return arr
==============================================================================================
# 冒泡排序
def bubble_sort(arr):
    lens = len(arr)
    for i in range(lens-1,-1,-1):
        flag = True                   # 用flag判断是否进行了转换操作
        for j in range(i):
            if arr[j] > arr[j+1]:
                arr[j],arr[j+1] = arr[j+1],arr[j]
                flag = False          # 当进行了转换操作时，flag变成了False
        if flag == True:
            break
    return arr

if __name__ =="__main__":
    arr = [3,4,2,8,9,5,1]
    print(bubble_sort(arr))

=============================================================================================
# 选择排序
def select_sort(arr):
    lens = len(arr)
    for i in range(lens):
        min = i
        for j in range(i+1,lens):
            if arr[min] > arr[j]:
                min = j
        arr[i],arr[min] = arr[min],arr[i]
    return arr

if __name__ =="__main__":
    arr = [3,4,2,8,9,5,1]
    print(select_sort(arr))

=============================================================================================
#插入排序
def insert_sort(arr):
    lens = len(arr)
    for i in range(1,lens):
        tmp = arr[i]
        n = i-1
        while n >= 0  and arr[n] > tmp:
            arr[n+1] = arr[n]         # 把所有元素向后退一位
            n = n-1
        arr[n+1] = tmp                # 将tmp插到这里，别忘了+1
    return arr

if __name__ =="__main__":
    arr = [3,4,2,8,9,5,1]
    print(insert_sort(arr))

================================================================================================
# 希尔排序
def shell_sort(arr):
    lens = len(arr)
    jmp = lens//2
    while jmp != 0 :                     # 当jmp等于1时，为整个序列的排序
        for i in range(jmp,lens):        # 这里的jmp相当于插入排序的1
            tmp = arr[i]
            n = i- jmp
            while n>=0 and arr[n]>tmp:
                arr[n+jmp] = arr[n]      # 向后推tmp位
                n = n-jmp
            arr[n+jmp] = tmp             # 记得不要忘了+jmp
        jmp = jmp//2
    return  arr

if __name__ =="__main__":
    arr = [3,4,2,8,9,5,1]
    print(shell_sort(arr))

====================================================================================================
#快速排序（经典方法）
def quick_sort(arr,a,b):
    if a>=b:
        return
    pivot = arr[b]
    left =a
    right = b-1
    while left<=right:
        while left<=right and arr[left]<pivot:
            left = left+1
        while left<=right and arr[right]>pivot:
            right =right-1
        if left<=right:
            arr[left],arr[right] = arr[right],arr[left]
            left = left+1
            right = right-1
    arr[left],arr[b] = arr[b],arr[left]
    quick_sort(arr,a,left-1)
    quick_sort(arr,left+1,b)

if __name__ == "__main__":
    list = [2, 3, 1, 4, 3, 0]
    quick_sort(list,0,len(list)-1)
    print(list)
    
================================================================================================
# 快速排序（加速方法） 经典法每次递归只确定一个位置（标准值），加速方法确定所有等于标准值的位置
def quick_sort(arr,l,r):
    if l >= r:
        return
    p = partition(arr,l,r)
    quick_sort(arr,l,p[0])
    quick_sort(arr,p[1],r)
 
def partition(arr,l,r):
    num = arr[r] # 默认以最后一个数作为基准
    less = l - 1
    more = r + 1
    cur = l
    while cur < more:
        if arr[cur] == num:
            cur += 1
        elif arr[cur] < num:
            arr[cur] , arr[less+1] = arr[less+1], arr[cur]
            cur += 1
            less += 1
        elif arr[cur] > num:
            arr[cur] , arr[more-1] = arr[more-1] , arr[cur]
            more -= 1
    return [less,more]
=============================================================================================
# 随机快排
def quick_sort_3(arr,l,r):
    import random
    if l >= r:
        return
    index = random.randint(l, r) 
    arr[index] , arr[r] = arr[r],arr[index] #随机选择一个数与最后一个数进行交换
    p = partition2(arr,l,r)
    quick_sort_3(arr,l,p[0])
    quick_sort_3(arr,p[1],r)

def partition2(arr,l,r):
    num = arr[r] # 默认以最后一个数作为基准
    less = l - 1
    more = r + 1
    cur = l
    while cur < more:
        if arr[cur] == num:
            cur += 1
        elif arr[cur] < num:
            arr[cur] , arr[less+1] = arr[less+1], arr[cur]
            cur += 1
            less += 1
        elif arr[cur] > num:
            arr[cur] , arr[more-1] = arr[more-1] , arr[cur]
            more -= 1
    return [less,more]
=============================================================================================
# 归并排序
def merge_sort(arr):
    if len(arr) == 1:
        return arr
    lens = len(arr)
    mid = lens//2
    left = merge_sort(arr[:mid])
    right = merge_sort(arr[mid:])
    result = []
    left_ptr = 0
    right_ptr = 0
    while left_ptr<len(left) and right_ptr < len(right):
        if left[left_ptr]<right[right_ptr]:
            result.append(left[left_ptr])
            left_ptr+=1
        else:
            result.append(right[right_ptr])
            right_ptr+=1
    result += left[left_ptr:]
    result += right[right_ptr:]
    return result


if __name__ == "__main__":
    list = [2, 3, 1, 4, 3, 0]
    sss=merge_sort(list)
    print(sss)
    
===============================================================================================
归并排序和快速排序的区别：
首先是分组策略的分组策略不同：
（1）快速排序是根据一个基准值进行分组，一组的值比基准值大，另一组的只比基准值小
（2）归并排序是直接将序列的前一半和后一半分开
在合并方面也不同
（1）快速排序的合并是直接合并，因为已经进行过比较了
（2）归并排序的合并需要进行比较才能进行合并
===============================================================================================
# 堆排序
def build_heap(list,size):
    for i in range(int(size/2)-1,-1,-1):    #最初建堆时，要从最后一个有子节点的位置开始往上调整
        ad_heap(list,i,size)

def ad_heap(list,i,size):
    left = 2*i+1
    right= 2*i+2
    maxs = i
    if i < int(size/2):     #i要小于int(size/2),因为最下面一层没有子节点了，只有有子节点的节点才能进行调整
        if left<size and list[left]>list[maxs]:
            maxs = left
        if right<size and list[right]>list[maxs]:
            maxs = right
        if maxs != i:
            list[maxs],list[i] = list[i],list[maxs]
            ad_heap(list,maxs,size)               #maxs位置的值被换了，所以要检查maxs位置是否满足条件

def heap_sort(list):
    size = len(list)
    build_heap(list,size)                       #自底向上调整
    for i in range(size-1,-1,-1):
        list[i],list[0] = list[0],list[i]
        ad_heap(list,0,i)                        # 注意这里是调整0的位置，而且堆的size变小

if __name__ == "__main__":
    list = [2, 3, 1, 4, 3, 0,5,7]
    heap_sort(list)
    print(list)
================================================================================================
#基数排序
def radix_sort(list):
    size = len(list)
    n = 1
    while n<=100:
        bucket = [[None for i in range(size)]for j in range(10)]
        for i in range(size):
            m = (list[i]//n)%10
            bucket[m][i] = list[i]
        k = 0
        for i in range(10):
            for j in range(size):
                if bucket[i][j]!=None:
                    list[k] = bucket[i][j]
                    k = k+1
        n = n*10
if __name__ == "__main__":
    list = [118,591,985,901,316,826,23,851,521,7]
    radix_sort(list)
    print(list)
