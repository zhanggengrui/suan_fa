#题目描述：寻找面积最大的岛屿（P116）
class area():                  # 设置一个类对象用来进行存储
    def __init__(self):
        self.cur = 0
        self.maxs = 0

def max_area(mat,a):
    row = len(mat)
    col = len(mat[0])
    for i in range(row):
        for j in range(col):
            if mat[i][j] == 1:
                a.cur = 0      #每次遍历之前要将a.cur重置为0
                dfs(mat,i,j,a)
                if a.cur>a.maxs:
                    a.maxs = a.cur
    return a.maxs

def dfs(mat,x,y,a):
    mat[x][y] = 2             #将遍历过的位置标记，以防重新遍历
    a.cur +=1
    if x>0 and mat[x-1][y] ==1:
        dfs(mat,x-1,y,a)
    if x<len(mat)-1 and mat[x+1][y] == 1:
        dfs(mat,x+1,y,a)
    if y>0 and mat[y-1][x] == 1:
        dfs(mat,x,y-1,a)
    if y<len(mat[0])-1 and mat[x][y+1] == 1:
        dfs(mat,x,y+1,a)
    return

if __name__ =="__main__":
    a = area()
    mat = [[0,0,0,0,1,1,0],
           [0,1,1,0,1,1,0],
           [0,1,1,0,0,0,0],
           [0,0,1,0,0,1,1],
           [0,0,0,0,0,0,0],
           [0,0,1,1,0,0,0],
           [0,0,0,1,0,0,1]]
    print(max_area(mat,a))
    for i in mat:
        print(i)
 ============================================================================================
 #书P257
 class Test():
    def __init__(self,arr):
        self.arr = arr
        self.n = len(arr)
        self.visited = [False]*self.n
        self.graph = [[None for i in range(self.n)] for j in range(self.n)]
        self.combination = ''
        self.sets = set()

    def creat_graph(self):
        for i in range(self.n):
            for j in range(self.n):
                if i == j :
                    self.graph[i][j] = 0
                else:
                    self.graph[i][j] = 1
        self.graph[3][5] = 0
        self.graph[5][3] = 0
        for i in range(self.n):
            self.dfs(i)

    def dfs(self,start):
        self.visited[start] = True
        self.combination = self.combination + str(self.arr[start])
        if len(self.combination) == self.n:
            if self.combination[2] !="4":
                self.sets.add(self.combination)
                self.combination = self.combination[:-1]
                self.visited[start] = False
                return                  # 如果这边只有一个return，那么最后一个无法取消标记，因为返回后再次直接进入循环
        for i in range(self.n):
            if self.visited[i] == False and self.graph[start][i] == 1:
                self.dfs(i)
        self.combination = self.combination[:-1]
        self.visited[start] = False
        return

    def print_sets(self):
        print(len(self.sets))
        for strs in self.sets:
            print(strs)


if __name__ =="__main__":
    arr = [1,2,2,3,4,5]
    t = Test(arr)
    t.creat_graph()
    t.print_sets()

 
 
