给定一个数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口 k 内的数字。滑动窗口每次只向右移动一位。
返回滑动窗口最大值。

示例:
输入: nums = [1,3,-1,-3,5,3,6,7], 和 k = 3
输出: [3,3,5,5,6,7] 
解释: 

  滑动窗口的位置                最大值
---------------               -----
[1  3  -1] -3  5  3  6  7       3
 1 [3  -1  -3] 5  3  6  7       3
 1  3 [-1  -3  5] 3  6  7       5
 1  3  -1 [-3  5  3] 6  7       5
 1  3  -1  -3 [5  3  6] 7       6
 1  3  -1  -3  5 [3  6  7]      7
注意：
你可以假设 k 总是有效的，1 ≤ k ≤ 输入数组的大小，且输入数组不为空。

解法：
class Solution:
    def maxSlidingWindow(self, nums, k):
        if len(nums) == 0:
            return []
        res = []
        helps = self.init_window(nums,k)
        res.append(helps[0][1])
        l = 0
        r = k
        while r < len(nums):
            while len(helps)!= 0 and helps[-1][1] <= nums[r]:
                helps.pop()
            helps.append([r,nums[r]])
            if l >= helps[0][0]:
                helps.pop(0)
            res.append(helps[0][1])
            r += 1
            l += 1
        return res
            
    def init_window(self,nums,k):
        l = 0
        r = 0
        helps = []
        while r < k:
            if len(helps) == 0:
                helps.append([r,nums[r]])
                r+=1
            elif nums[r] >=helps[-1][1]:
                helps.pop()
            else:
                helps.append([r,nums[r]])
                r += 1
        return helps
===========================================================================================================
题目：
给定数组arr和整数num 返回共有多少个子数组满足：
                 max(arr[i:j]) - min(arr[i:j]) <= num
要求：时间复杂度为0(N)

解答：
def getnum(arr,num):
    if arr == None or len(arr)==0:
        return 0
    res = 0
    mins = []
    maxs = []
    left = 0
    right = 0
    while left < len(arr):
        while right <len(arr):
            while len(mins)!= 0 and arr[mins[-1]] >= arr[right]:
                mins.pop()
            mins.append(right)
            while len(maxs) != 0 and arr[maxs[-1]] <= arr[right]:
                maxs.pop()
            maxs.append(right)
            if arr[maxs[0]] - arr[mins[0]] > num:
                break
            right += 1
        if mins[0] == left:
            mins.pop(0)
        if maxs[0] == left :
            maxs.pop(0)
        res += right-left
        left += 1
    return res

=====================================================================================
LEETCODE76
给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字母的最小子串。

示例：
输入: S = "ADOBECODEBANC", T = "ABC"
输出: "BANC"

说明：
如果 S 中不存这样的子串，则返回空字符串 ""。
如果 S 中存在这样的子串，我们保证它是唯一的答案。

解答：
import sys
class Solution:
    def minWindow(self, s, t):
        left = 0
        right = 0
        d = dict()
        min_size = sys.maxsize
        res = ""
        for i in t:
            d[i] = d.get(i, 0) + 1
        curnum = len(t)
        while right < len(s):
            if curnum != 0:
                if s[right] in d :
                    if d[s[right]]>0:
                        curnum -= 1
                    d[s[right]] -= 1
                right += 1
            else:
                while curnum == 0:
                    if (right - left) < min_size:
                        res = s[left:right]
                        min_size = right - left
                    if s[left] in d:
                        if d[s[left]] >= 0:
                            curnum += 1
                        d[s[left]] += 1
                    left += 1

        while curnum == 0:
            if (right - left) < min_size:
                res = s[left:right]
                min_size = right - left
            if s[left] in d:
                if d[s[left]] >= 0:
                    curnum += 1
                d[s[left]] += 1
            left += 1
        return res

方法二：
import sys


class Solution:
    def minWindow(self, s, t):
        left = 0
        right = 0
        t_d = dict()
        for i in t:
            t_d[i] = t_d.get(i, 0) + 1
        min_size = sys.maxsize
        res = ""
        window_d = dict()
        required = len(t_d)
        formed = 0
        while right<len(s):
            window_d[s[right]] = window_d.get(s[right],0)+1
            if s[right] in t_d and window_d[s[right]] == t_d[s[right]]:
                formed += 1
            while left <= right and formed == required:
                if (right-left)<min_size:
                    min_size = right-left
                    res = s[left:right+1]
                window_d[s[left]] -= 1
                if s[left] in t_d and window_d[s[left]] < t_d[s[left]]:
                    formed -= 1
                left += 1
            right += 1
        return res

归纳：
while r <len(s):
  加入r
  while l <=r and 某条件成立：
    l向右走
    更改条件现状
  r向右走
 

